# PaperMatchingAlgorithm
在一个大的动态系统中，分为：请求者和服务者，每个请求者需要的数据不一样，每个服务者提供的数据不一样，如何快速的进行匹配请求者和服务者，使得整个匹配组合最优或者最稳定？

如何使得请求者获得数据达到最满意或者接近最满意？如何使得服务者提供的数据全部使用或者接近全部使用？

这也就是说明了如何使得请求者的额外花费最小？如何使得服务提供者提供的数据最大限度的被使用？



算法如下：
1、	普通的算法Common（COM for short）：DR用户优先原则，从DR集合中依次选择一个DR用户，当DR用户遇到一个满足容忍时间DS用户，则与这个DS用户进行匹配；DS用户优先原则，从DS集合中依次选择一个DS用户，当DS用户遇到一个可以满足容忍时间的DR用户，则与这个DR用户进行匹配。

2、	半排序的算法Semi Sort（SS for short）：DR用户优先原则，先对DS用户按照共享的流量大小进行排序，然后当一个DR用户遇到一个满足容忍时间DS用户，则与这个DS用户进行匹配；DS用户优先原则，先对DR用户按照需要的流量大小进行排序，然后当一个DS用户遇到一个可以满足容忍时间的DR用户，则与这个DR用户进行匹配。

3、	全排序的算法All Sort（AS for short）：分别对DR用户按照需要的流量大小进行排序，对DS用户按照共享的流量大小进行排序；DR用户优先原则，当一个DR用户遇到一个满足容忍时间DS用户，则与这个DS用户进行匹配；DS用户优先原则，当一个DS用户遇到一个可以满足容忍时间的DR用户，则与这个DR用户进行匹配。

4、	稳定搭配算法Stable Matching Proglem（SMP for short）：DR用户优先原则，分别计算出每个DR用户对DS用户集合的一个偏好程度的排序集合RS，每个DR用户从它偏好的RS集合中选取第一个且没有匹配的DS用户进行匹配；DS用户优先原则，分别计算出每个DS用户对DR用户集合的一个偏好程度的排序集合SR，每个DS用户从它偏好的SR集合中选取第一个且没有匹配的DR用户进行匹配。

5、	随机匹配算法Random Matching （RM for short）：DR用户优先原则，一个DR用户随机的从DS集合中选择一个满足容忍时间的DS用户，与这个DS用户进行匹配；DS用户优先原则，一个DS用户随机的从DR集合中选择一个满足容忍时间的DR用户，与这个DR用户进行匹配。

6、	两端匹配算法Two Ends Matching（TEM for short）：分别对DR用户按照需要的流量大小进行排序，对DS用户按照共享的流量大小进行排序；DR用户优先原则，首先从DR集合中选择第一个DR用户，在DS集合中从头依次找到一个满足容忍时间的DS用户进行匹配，再次用从DR集合中选取最后一个DR用户，在DS集合中从尾依次找一个满足容忍时间的DS用户进行匹配，重复上面的步骤，直到匹配完成；DS用户优先原则，首先从DS集合中选择第一个DS用户，在DR集合中从头依次找到一个满足容忍时间的DR用户进行匹配，再次用从DS集合中选取最后一个DS用户，在DR集合中从尾依次找一个满足容忍时间的DR用户进行匹配，重复上面的步骤，直到匹配完成。

7、	我们的算法（OTM for short）：分别对DR用户按照需要的流量大小进行排序，对DS用户按照共享的流量大小进行排序；DR用户优先原则，分别计算出每个DR用户对DS用户集合的一个偏好程度的排序集合RS，每个DR用户从它偏好的RS集合中选取第一个且没有匹配的DS用户，计算这个DS用户与其他的DR用户的差异值是否比当前的DR用户的差异值大，如果大，则匹配当前的DR用户和DS用户，如果小则匹配最小差异值的DR用户和DS用户；DS用户优先原则，分别计算出每个DS用户对DR用户集合的一个偏好程度的排序集合SR，每个DS用户从它偏好的SR集合中选取第一个且没有匹配的DR用户，计算这个DR用户与其他的DS用户的差异值是否比当前的DR用户的差异值大，如果大，则匹配当前的DR用户和DS用户，如果小则匹配最小差异值的DR用户和DS用户。
